\ifthenelse{\value{cols}=1}{
    \setlength{\columnsep}{20pt} % Spacing tra le colonne
    \begin{multicols}{2}[\section{Multi Agent}]
}{
    \section{Multi Agent}
}
    This second part regards the development of the multi agent, in particular, the addition of a second agent (\textit{"pal"}) that is able to operate in the \textit{Deliveroo.js} setting. The two agents should be able to communicate, update the their internal beliefs with the shared information, coordinate and negotiate common solutions (e.g., decide who should pick up a certain parcel or collaborate to achieve goals).
    \medskip\\    
    Moreover, as said previously, the multi agent script is the same as the single agent one, and the multi agent mode can be enabled with a parameter when launching the agent's script.

    \subsection{Additions to the Single Agent}
        With respect to the standard single agent components, several important components were added to ensure the multi agent compatibility. Doing so, we allow the multi agent to be able to operate even in the absence of the pal, making it resilient to those situations in which the pal may unexpectedly disconnect.
        \medskip\\
        Similarly to the single agent, also in the multi agent case we have two specific multi agent tokens with the associated ids, this allows both the agents (i.e., \textit{agent1} and \textit{agent2}) to communicate. Follows a description of the main additions with respect to the single agent.

        \subsubsection{Pal Memory}
            The first step is to define an additional memory to contain all the information about the pal, in particular, his id, his position, his current intention and the timestamp of the last update we received from him. The pal's id will be set at the beginning of the agent script, since both of the ids and tokens are hardcoded in it, while the other information will be set and updated via message communication.
            \medskip\\
            Another component modified in this regards is the \textit{reviseMemory} function. In particular, if the pal fails to communicate with us for a certain time window, we consider hil as disconnected and, therefore, we clear his memory information. This allows the agent, despite him continuing to send non-blocking "\textit{say}" messages to the non-existing pal, to operating as a single agent assuming that the pal is nowhere and carries no parcels.
            
        \subsubsection{Communication}
            The most important difference with respect to the single agent is the presence of a communication part that allows the agents to send an receive messages. In particular, we have defined four types of messages, one of which will be described in details in a next section (\ref{shareRequest}). The other three message types allow the agents to synchronize their beliefs and operate accordingly. Following our rapid-option-generation strategy and after multiple failed attempts with structured message share, we decided to adopt a "\textit{UDP-like}" message share strategy for these three message types: if the pal is listening, he will update his belief accordingly, otherwise nothing problematic will happen. Similarly for the message reception strategy: if the pal is operative and sends us updates, we will update our belief, otherwise we will continue to operate with our current belief without problems.
            \medskip\\
            Here is a rapid description of the three "\textit{UDP-like}" message types:
            \begin{itemize}
                \item \textbf{\textit{MSG\_positionUpdate}}: in every \textit{onYou} callback, we use this kind of message to share the agent's current position with the pal. When the agent receives this message type, he will update his belief with the pal's new position, will set the new \textit{last update} from the pal, will update the pal's entry in the \textit{agent memory} and use the new pal's position to update its internal \textit{time map}, allowing him to explore different parts of the map with respect to the pal;
                \item \textbf{\textit{MSG\_memoryShare}}: after every \textit{memory revision}, the agent sends the revised verion of his memory to the pal, in particular the \textit{parcel and agent memories}, the parcels he is currently carrying  and, again, its updated position. On the other hand, when the agent receives this type of message he will save the pal's carried parcels in a dedicated variable, he will remove from his \textit{parcel memory} the parcels that, in his belief, are carried by the pal (if the pal is still carrying them, the agent will add these entries back to his parcel memory), and then, update his \textit{parcel} and \textit{agent} memories based on the information shared by the pal. Finally, he will call the handler of the \textit{MSG\_positionUpdate} type to update the pal position;
                \item \textbf{\textit{MSG\_currentIntention}}: when the agent pushes a new \textit{next intention}, he will also send it to the pal. If the agent receives this message, he will update the current pal's intention.
            \end{itemize}
            
            \subsubsection{Options and Filtering}
                The presence of a collaborative pal, allows us to introduce some improvements during the option generation and filtering procedures. The first regards the best pick up option generation, in particular the reward computation. When the agent process all the single parcels, he will compute the reward of the single parcel, both for him and the pal, using his internal information about the pal without any communication. If the pal, for some reason, is not present in the agent's memory, his reward will automatically be zero. This additional pal reward allows the agent to perform additional filtering on the parcel: if the agent's reward is bigger than the pal's reward or the rewards are the same but his distance to the parcel is lower, then he will generate an associated option. Furthermore, if the current pal's intention is a "\textit{go\_deliver}", the agent know that the pal will probably ignore all the parcels and, therefore, he should always generate an option.
                \medskip\\
                The second, and most important, improvement regards the introduction of a new option type: "\textit{share\_parcels}". This particular option is designed to solve "\textit{corridor-like}" situations, where one agent can pick up parcels but not deliver them, while the other agent can deliver parcels but not pick them up. This option is pushed if no \textit{best option} is identified before (there are not "\textit{go\_pick\_up}" or "\textit{go\_deliver}"), if the agent is carrying parcels and there is a path to reach the pal. Furthermore, to handle the situation in which the path to a delivery is obstructed only temporarily, we introduced a dedicated counter. This allows to commit to a \textit{share\_parcels} intention only if the path is effectively obstructed and not if the pal is only traversing one cell of it.
            
            \subsubsection{Plans}\label{shareRequest}
                As said before, to handle \textit{corridor-like} situations, we specifically added a new "\textit{share\_parcels}" intention, called by the agent that is carrying parcels but cannot deliver because the pal is blocking the path to the delivery. Furthermore, to avoid a new option generation to break the cooperation phase, a dedicated flag has been added and it is turn on during the execution of the following plans. This will block the push of new intentions during a collaboration phase.

                \paragraph{ShareParcels Plan}
                    To handle this new intention, a new plan "\textit{ShareParcels}" has been introduced, where the first step is to send a "\textit{MSG\_shareRequest}" type message containing his current position, using the "\textit{emitAsk}" utility to await for the pal's response. The pal, or the server, can respond in different ways:
                    \begin{itemize}
                        \item \textbf{"timeout" or null}: in the first case, the pal fail to respond in time so the server sends a "timeout", while the second case is used to handle the single agent case in which the emitAsk wrapper will automatically return a \textit{null} without any communication. In both cases, the intention fails immediately;
                        \item \textbf{"false"}: the pal refuses our request so the intention fails immediately;
                        \item \textbf{"you\_move"}: the agent is obstructing the pal (currently, to handle the \textit{share\_parcels} intention, the pal needs a path of at least four positions between him and the agent), so it move away to create enough space for the exchange. If no path is available, then the intention fails, otherwise when the move is complete and there is enough space to handle the exchange, the agent sends another \textit{MSG\_shareRequest} message;
                        \item \textbf{"true"}: the pal accepts the agent's request and sends him the necessary coordinates to perform the exchange. In particular, a "\textit{wait position}", where the pal will await for the parcels, an "\textit{exchange position}", where the agent should drop his parcels, and an adjacent "\textit{support position}", where the agent should move after dropping the parcels and await for the pal to pick them up.
                    \end{itemize}
                    Once the pal responds with a "\textit{true}" message, the agent can proceed handling the intention. The first step is to move to the \textit{exchange position}, where the agent will await for the pal arrival to the \textit{wait position}. If, for some reason, the pal changes his current intention, that means that he failed the parcel recovery intention (he bumped into another agent or found his path blocked), so, also the agent fails this intention. After that, the agent will drop his parcels on the spot, move to the \textit{support position} and await for the pal to pick up the parcels. After this, the intention is successfully complete.
                    Once the pal responds with a "\textit{true}" message, the agent can proceed handling the intention. The first step is to move to the \textit{exchange position}, where the agent will await for the pal arrival to the \textit{wait position}. If, for some reason, the pal changes his current intention, that means that he failed the parcel recovery intention (he bumped into another agent or found his path blocked), so, also the agent fails its intention. Otherwise, after that, the agent will drop his parcels on the spot, move to the \textit{support position} and await for the pal to pick up the parcels. After this, the intention is successfully complete.
                
                \paragraph{Handling the MSG\_shareRequest Message Type}
                    On the other hand, if the agent receives a "\textit{MSG\_shareRequest}" message, he will handle it accordingly. In particular, he will update the pal's position in the memory and will compute a path: if he is currently carrying parcels, the path will allow him to deliver first and then reach the pal, otherwise the path is directly between the agent and the pal. If, for some reason, this path does not exist, the response will be "false" and the intention will be rejected. Otherwise, the full path will be analyzed to compute the former three positions: the middle point in the path will become the \textit{wait position}, the next cell (from the point of view of the agent) the \textit{exchange position} and the following cell the \textit{support position}. If these exists, the agent will push a "\textit{recover\_shared\_parcels}" option to commit to the share and send a "true" response to the pal containing these positions.
                    \medskip\\
                    Given how this approach is structured, as said before, the path must be of at least four positions. If not, the agent will check if he can reach a delivery and if the path to such delivery allows to obtain at least four free positions for the exchange. If so, he will commit to the movement and repeat this process afterwards, otherwise he will ask the pal to make space with a "you\_move" response, sending also the number of required free cells.

                \paragraph{RecoverSharedParcels Plan}
                    To handle the "\textit{recover\_shared\_parcels}" intention, a new plan "\textit{RecoverSharedParcels}" has been introduced where, differently from before, the agent already knows the three exchange positions. First, if the agent needs to perform a delivery (decided in the previous message handler), he will first commit to it, then he will proceed with the move to the \textit{wait position}. Once there, he will wait for the pal to be in the \textit{exchange position}, for him to drop the parcels there and to move to the \textit{support position}. Similarly to the "\textit{ShareParcels}" plan, the pal changes his current intention, that means that he failed the share intention, so, also the agent fails this intention. Otherwise, at this point, the agent will move to the \textit{exchange position}, pick up the parcels and conclude the intention with success.        
\ifthenelse{\value{cols}=1}{
    \end{multicols}
}{
    % Pass
}
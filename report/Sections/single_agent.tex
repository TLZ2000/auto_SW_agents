\section{Single Agent}
    This part regards the development of a simple single agent, able to perform the basic functions to operate in the \textit{Deliveroo.js} setting. In particular, this should include the ability to represents and manage an internal belief system, built from sensing data received from the server and able to perform revision of outdated or no longer valid beliefs. Based on these beliefs, the agent should be able to define and activate  intentions, also performing revision of older intentions, and also act in the environment to achieve such intentions. To achieve the intentions the agent should use a set of predefined plans or an integration with a planner utility to perform the correct actions.
    \medskip\\    
    In particular, our single agent operates with the same script as the multi agent configuration, as this multi agent configuration is resilient to the absence of the second agent. Specifically, the single agent configuration will avoid to send messages to the non existing companion and, in all of those situations where it is necessary to know the companion information, like its position or the parcels he is carrying, the agent will consider the companion as null, so like he is nowhere and he is carrying no parcels.

    \subsection{Initial Connection}
        The first step is to initialize the agent's \textit{belief set}, this include the initialization of an empty memory. Then, the script will evaluate the command line parameters and will initialize the connection using a specific single agent token or, if required, a token created on the fly. The script will initialize the intention system, will add the predefined plans to its internal library and will initialize the callbacks for the \textit{updates} from the server, like "\textit{onParcelsSensing}" and "\textit{onYou}". Lastly, the script defines a \textit{Promise} on the "\textit{onMap}" and "\textit{onConfig}" callbacks on their resolution before continuing with the normal execution, in particular a temporized loop both on the "\textit{agent's memory revision}" and the "\textit{option generation}" phases.

    \subsection{Belief}
        In this part we cover the \textit{BeliefSet} class regarding the single agent part. In particular it is composed by an initial setup phase where we define the game map and the game configurations, then an "\textit{environment sensing}" part where we update the agent's belief using the information sensed from the environment and a last "\textit{memory revision}" phase where we remove old and no longer valid information from the memory.

        \subsubsection{Initial Configuration}
            The first step includes the initialization of the internal memory, the most important components are the "\textit{agent memory}", in which is stored the information about the other agents, the "\textit{parcel memory}", in which is stored the information about the parcels, and the "\textit{me memory}", in which is stored the information about our agent, like its position, id and token.
            \medskip\\
            The second step is to define an internal representation of the game map. Firstly, we define a simple matrix containing the type of the tiles given their $[x, y]$ position. Then we perform a check on the validity of each cell, automatically setting as "wall" (type $0$) all those cells that have no neighbors and thus not reachable. Lastly, we use the information of this matrix to define a graph structure on the map itself, where each node represent a single tile containing the associated position, type and neighbors. This allow us to perform efficient navigation using BFS search. Associated to this map, we also define another matrix called "\textit{time map}", of the same sizes of the game map, which contain the "last visited timestamp" of each map tile. This map is needed during the exploration phase.
            \medskip\\
            Finally, we save the game configuration in a dedicated map, to have an easier access to it during the game execution.

        \subsubsection{Environment Sensing}
            During the normal execution, the agent will receive the information about the parcels and the agents that he is able to sense and its own updated information from the server. Upon reception of these messages, the belief set will update its internal representation, to be coherent with the new setting of the environment.  In particular, the "\textit{onYou}" handler will update the agent's id (necessary in the case in which we generate a random token on the fly), its current position and the time map, accordingly to the current agent's position (all the cells in the agent field of view are updated with the current timestamp).
            \medskip\\
            Regarding the "\textit{onParcelsSensing}", the server will send the information of the parcels sensed by the agent, which will be inserted in its internal parcel memory updating the entries of already seen parcels and creating new entries for the newly seen parcels. The same process is performed also for the "\textit{onAgentsSensing}".

        \subsubsection{Memory Revision}
            

    \subsection{Options and Filtering}
        options generation, e filtering con reward (migliore pickup e delivery)

    \subsection{Intention}
        spiegare classi nel file Intentions.js dicendo come gestiamo il push di nuove intention e come facciamo intention revision

    \subsection{Plan}
        spiegare i vari piani, come li gestiamo, come facciamo revision dei piani (come la mettiamo insieme a option generation)

    \subsection{Planning}
        come abbiamo implementato il planning e per cosa, spiegare che fa schifo, spiegare roba dei negative prepositions (in conflitto con closed world assumption) che fa crashare il FF planner

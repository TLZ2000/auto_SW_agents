\ifthenelse{\value{cols}=1}{
    \setlength{\columnsep}{20pt} % Spacing tra le colonne
    \begin{multicols}{2}[\section{Single Agent}]
}{
    \section{Single Agent}
}
    This section regards the development of a simple single-agent capable of performing the basic functions required to operate in the \textit{Deliveroo.js} environment. Specifically, the agent must represent and manage an internal belief system constructed from sensory data received from the server, with the capacity to revise outdated or no longer valid beliefs. Based on these beliefs, the agent should be able to define and activate intentions, revise older intentions, and act in the environment to achieve them. To achieve its intentions, the agent should use a set of predefined plans or integrate with a planner utility to execute the appropriate actions.
    \medskip\\    
    In particular, the single-agent operates using the same script as the multi-agent configuration, which is designed to be resilient to the absence of a second agent. In the single-agent setup, the agent avoids sending messages to the non-existent companion, and, in situations requiring information about the companion, such as its position or its carried parcels, the agent treats the companion as null, assuming no location and no parcels.

    \subsection{Initial Connection}
        The first step is to initialize the agent's \textit{belief set}, this includes the initialization of an empty memory. Then, the script evaluates the command-line parameters and initializes the connection using a specific single-agent token or, if necessary, a token generated on the fly. The script initializes the intention system, adds the predefined plans to its internal library and sets up the callbacks for \textit{updates} from the server, such as "\textit{onParcelsSensing}" and "\textit{onYou}". Lastly, the script defines a \textit{Promise} on the "\textit{onMap}" and "\textit{onConfig}" callbacks, awaiting their resolution before continuing the normal execution, specifically, with a temporized loop on both the "\textit{agent's memory revision}" and "\textit{option generation}" phases. The temporization for both loops is currently set at $50\;\text{ms}$: from our tests, this is the shortest possible time interval in which significant events may happen, with the lower bound corresponding to the agent's movement duration. This choice is justified by the rapidly evolving nature of the \textit{Deliveroo.js} environment, keeping the overall approach simple and avoiding manual invocation of these functions.

    \subsection{Belief}
        This section covers the "\textit{BeliefSet}" class regarding the single-agent. It consists of an initial setup phase, where the game map and the game configuration are defined, an "\textit{environment sensing}" component where the agent's beliefs are updated using the information sensed from the environment, and a final "\textit{memory revision}" phase, where outdated or unreliable information is removed from memory.

        \subsubsection{Initial Configuration}
            The first step includes the initialization of the internal memory. The key components are the "\textit{agent memory}", which stores information about other agents, the "\textit{parcel memory}", which stores information about parcels, and the "\textit{me memory}", which stores information about the agent itself, such as its position, id, and token.
            \medskip\\
            The second step defines an internal representation of the game map. Firstly, a matrix is created to store the tile type given their $[x, y]$ position. Then, each cell is validated, automatically marking unreachable cells, those lacking neighbors and thus unreachable, as "wall" (type $0$). Lastly, using this matrix, a graph structure on the map itself is built, where each node represents a tile with its position, type, and neighbors. This structure enables efficient navigation using BFS. Additionally, associated to the game map, a "\textit{time map}" matrix is defined, matching the its size, which contains the "last visited timestamp" for each tile. This is used during the exploration phase.
            \medskip\\
            Finally, the game configuration is stored in a dedicated map for easier access during the game execution.

        \subsubsection{Environment Sensing}
            During the normal execution, the agent receives information from the server about sensed parcels, sensed agents and its own updated information. Upon receiving these messages, the belief set updates its internal representation to remain consistent with the current environment.
            \medskip\\
            In particular, the "\textit{onYou}" handler updates the agent's id (necessary when using a randomly generated token), its current position, and the time map. Accordingly to the current agent's position, all cells in the time map within the agent's field of view are updated with the current timestamp.
            \medskip\\
            Regarding the "\textit{onParcelsSensing}", the server provides the information on parcels sensed by the agent. This information is inserted into the internal parcel memory, updating existing entries for previously seen parcels and creating new entries for newly detected ones. A timestamp with the sensing time is stored with each entry to allow an accurate revision later. The same process is performed also for the "\textit{onAgentsSensing}".

        \subsubsection{Memory Revision}\label{memoryRevision}
            The agent's belief may contain outdated information, such as a parcel no longer visible due to being outside the sensing range. While this information may remain relevant for a short period, it becomes unreliable over time. For this reason, the final fundamental component of the "\textit{BeliefSet}" class is the \textit{memory revision} system, whose purpose is to remove these old data.
            \medskip\\
            In the \textit{Deliveroo.js} setting, the server sends sensing updates only when events occur on existing and visible entities, such as a parcel appearing or an agent entering the sensing range, but does not notify the agent when entities disappear or move out of range. Consequently, if a parcel expires or an agent leaves the sensing area, no update is sent. To handle this, a \textit{time window based approach} is adopted.
            \medskip\\
            For parcel revision, all parcels in memory are cycled. If a parcel's position lies within the current sensing range and its last observed timestamp is recent (within the \textit{parcel's decay interval}, which is the minimal interval in which state changes about parcels may occur), the parcel is retained, as its presence is still reliable. If the timestamp is not recent, the parcel is assumed to have either expired or been collected by another agent, and so, is removed. If the parcel lies outside the sensing range, a larger time window is used before removal, since we cannot be sure if the parcel is still there or not. The same logic is applied to the \textit{agent memory}, using the \textit{agent's movement duration} as time interval.

    \subsection{Options and Filtering}
        To act in the environment, the agent must first identify possible and desirable options based on its current belief state. Once all options are identified, a filtering step selects the best one.
        \medskip\\
        This process is implemented in the \textit{optionsGeneration} function. It first identifies the best option (i.e., the one with the highest reward, see \ref{best_pickup} for reward definition) by comparing the best "\textit{go\_pick\_up}" option and the "\textit{go\_deliver}" option to the nearest reachable delivery cell, based on the agent's current beliefs. The selected best option is then compared to the currently executed intention, and, if it yields a higher reward, the current intention is stopped and replaced with the new option.
        \medskip\\
        The function includes also control logic to prioritize the completion of "\textit{go\_pick\_up}" options in some specific conditions. In particular, two conditions are identified: the first one is when no best option exists, to prevent pushing an "\textit{explore}" option, the current intention is let to finish. While, the second one is when the best option is a "\textit{go\_deliver}", to prevent disruptive behavior such as switching direction to go deliver just before reaching a parcel to pick up, the current intention is let to finish.
        \medskip\\
        An additional case is handled when there is no best option and the current intention is not "\textit{go\_pick\_up}". In this situation, an "\textit{explore}" option is generated using either a "\textit{time-based}" or a "\textit{distance-based}" strategy, with preference given to the "\textit{time-based}" one.
        \medskip\\
        Finally, the \textit{optionsGeneration} function includes a flag to prevent executing it multiple times in parallel and performs a check to avoid running it during plan generation by the automated planner.
        
        \subsubsection{Filtering the Best "go\_pick\_up" Option}\label{best_pickup}
            For each parcel in the agent's memory that is not carried by any agent (i.e., a \textit{free parcel}), a "\textit{go\_pick\_up}" option is generated along with the associated estimated reward. The estimation accounts for both the reward of the parcel to pick up and the expected reward from the parcels currently carried. To compute this estimation, the total path, computed via BFS, is also considered. This includes both the route to pick up the parcel and the route to deliver it to the nearest reachable delivery. The agent's movement duration and the parcel decay interval are used to project the parcel rewards over time, and the last visit time for the target parcel is used to approximate its current score if it lies outside the sensing range. The resulting reward is scaled using fixed factors to prioritize proximity, based on the fact that picking up a nearby low-reward parcel is more cost-effective than traveling to collect a distant high-reward one.
            \medskip\\
            Once all options are generated, the one with the highest reward is selected. In cases where multiple options have equal reward, the one closest to the agent is chosen.
            \medskip\\
            If no best option is selected, typically because all options have zero reward, often due to all delivery cells being occupied by other agents, an alternative selection is performed: a simplified expected reward estimate is computed using the ratio between a parcel's raw score and its distance from the agent.

        \subsubsection{Computing "go\_deliver" Option}
            To construct the "\textit{go\_deliver}" option to the nearest reachable delivery cell, the first step is to verify whether the agent is carrying parcels: if not, no "\textit{go\_deliver}" option is generated (no need to deliver). Otherwise, the path to the nearest delivery cell is computed. This path is then used to estimate the expected reward of the carried parcels, following the same logic used for the best "\textit{go\_pick\_up}" option (see \ref{best_pickup}). If no path exists, it means that all delivery cells are blocked by other agents, and, therefore, the "\textit{go\_deliver}" option is not generated.
            \medskip\\
            To prevent unwanted behavior, such as excessive preference for "\textit{go\_pick\_up}" options, the number of moves performed by the agent while carrying parcels is tracked. This move counter is used, along with a fixed scaling constant, to increase the reward of the "\textit{go\_deliver}" option proportionally. This raises the likelihood of performing a delivery as the number of moves grows. The counter is reset after the delivery is completed.

    \subsection{Intentions}
        The intention management system is highly based on the code presented in the laboratories, with some key modifications. The most significant change regards "\textit{intention revision}": the intention queue has been removed in favor of maintaining only a current and a next intention. This decision reflects the fast-changing nature of the \textit{Deliveroo.js} environment, where a queue of sequential intentions is likely to become obsolete before execution. The simplified model focuses on the current intention being executed and a next intention that is considered better and will replace the current one as soon as possible.
        \medskip\\
        The async \textit{loop} function in the "\textit{IntentionRevisionReplace}" class serves the current intention, if existing. Once the intention is achieved, it is removed and replaced by the next intention, if any. The async \textit{push} function receives a new option from \textit{optionsGeneration} and determines whether to store it as the next intention. If so, the \textit{stop} function is invoked on the current intention, causing its termination and enabling the \textit{loop} to replace it with the new one.
        \medskip\\
        Since \textit{optionsGeneration} may rapidly push identical options multiple times, a mechanism is required to distinguish between new intentions (that must be replaced) and duplicates (that must be discarded). To address this, a comparison function, \textit{areIntentionsEqual}, is used to compare the parameters of the new option with the predicate of the next intention, if existing, or the predicate of the current intention, if no next intention exists, discarding redundant entries.

    \subsection{Plans}
        Due to the fact that the code is split across multiple files, it was necessary to make the plans, defined in \textit{agent.js}, accessible across modules. To achieve this, the plan library was created directly within the "\textit{IntentionRevision}" class, where the plans are added. When the \textit{achieve} function is called on an intention, the plan library is passed as a parameter to allow selection of the appropriate plan for execution.
        \medskip\\
        The basic "\textit{Plan}" class is the same as the one presented in the laboratories, with one modification: the plan library is also passed when invoking a sub-intention.
        \medskip\\
        Using the "\textit{Plan}" class, the predefined set of plans used by the agent to execute its intentions is defined.

        \subsubsection{Explore Plan}
            The "\textit{Explore}" plan serves the "\textit{explore}" intention. It consists of a "\textit{go\_to}" sub-intention aimed at exploring the map to discover parcels to pickup. The target coordinates are determined using one of two randomly selected strategies: time-based or distance-based. Both strategies first compute a list of explorable spawn cells using BFS.
            \medskip\\
            The time-based strategy uses the \textit{time map} from the "\textit{BeliefSet}" to prioritize cells that have not been visited for a long time. The distance-based strategy assigns higher selection probability to cells farther from the agent. If the time-based strategy yields no valid target, the system uses the distance-based strategy. If no spawn cells are available, the destination is set as the nearest delivery cell, if available.
            \medskip\\
            The probability of selecting cells in the time-based exploration strategy is computed as follows. First, the \textit{age} of each explorable cell is calculated as the time in milliseconds since the cell was last seen, then normalized to the range $[0, 1]$. Concurrently, the \textit{Manhattan distance} from the agent to each cell is computed, and a logarithmic transformation $\log(\text{distance} + 1)$ is applied to reduce scale disparity between age and distance. A softmax-like \textit{priority} is then assigned to each cell as:
            \begin{gather*}
                priority_{cell} = \frac{e^{\alpha \cdot age_{cell} - \beta \cdot distance_{cell}}}{\sum_{c \in cells}e^{\alpha \cdot age_c - \beta \cdot distance_c}}
            \end{gather*}
            From testing, the optimal parameter values were found to be $\alpha = 5$ and $\beta = 1$. A target cell is then selected at random, weighted by the computed priorities.

        \subsubsection{GoPickUp Plan}
            The "\textit{GoPickUp}" plan serves the "\textit{go\_pick\_up}" intention. It consists of a "\textit{go\_to}" sub-intention that moves the agent to the target cell containing the parcel, followed by a pickup action. The pickup is executed through a wrapper that prevents multiple emit actions from occurring in parallel, manually marks the parcel as carried by the agent, and performs the pickup operation.

        \subsubsection{GoDeliver Plan}
            The "\textit{GoDeliver}" plan serves the "\textit{go\_deliver}" intention. Like the "\textit{GoPickUp}" plan, it consists of a "\textit{go\_to}" sub-intention to move to the target delivery cell, followed by a putdown action. The putdown is executed through a wrapper that prevents parallel emit actions, resets the moves counter, manually removes the delivered parcels from the agent's memory and adds them to an ignore list to prevent consistency issues, and performs the putdown operation.

        \subsubsection{Move Plan}
            The "\textit{Move}" plan serves the "\textit{go\_to}" intention. It begins by computing a path from the agent's current position to the target coordinates using either BFS or an automated planner (see \ref{planning}). If a valid path is found, the agent follows it step by step until reaching the destination, where the plan concludes successfully. If no path is found, the plan fails.
            \medskip\\
            During the path-following phase, several checks ensure the action remains valid and relevant. For "\textit{go\_pick\_up}" intentions, the agent verifies whether a parcel is still present at the destination. If not, the intention fails due to lost relevance. The path itself is also monitored: if a cell in the path is occupied by another agent for more than three consecutive moves, the path is considered blocked and the intention fails. Additionally, if the adjacent cell the agent intends to move into is currently occupied, the intention fails immediately. A final fail-safe manages scenarios where the agent is unable to move at all, and thus it is stuck, this also results in failure.
            \medskip\\
            In all such cases, the intention is failed regardless of the situation. This aligns with the adopted strategy of frequently generated options: rather than attempting to fix invalid intentions, they are discarded, allowing a new and valid intention to be almost immediately selected and executed.

    \subsection{Planning}\label{planning}
        In the domain of autonomous software agents, plans can be automatically generated through \textit{automated planning}, typically using the \textit{PDDL language} and general-purpose planners. These planners require two inputs: a \textit{domain file}, which defines the entities, actions, and rules of the domain, and a \textit{problem file}, which specifies a particular instance of the environment, including the specific goal to achieve.

        \subsubsection{Domain Definition}
            The domain is defined in a dedicated domain file. In particular, the "\textit{go\_to}" intention is modeled using \textit{automated planning} to compute the associated path. For this reason, the domain includes only the components necessary for movement, excluding components such as parcels and their scores.
            \medskip\\
            The map is represented as a set of \textit{tile} entities connected using directional predicates: \textit{right}, \textit{left}, \textit{up}, and \textit{down} (e.g., the predicate "\textit{right ?t1 ?t2}" indicates that tile \textit{?t1} is to the right of \textit{?t2}). The \textit{free} predicate identifies tiles not occupied by any agent. The agent itself is represented using the \textit{me} predicate, and its current position is indicated using the \textit{at} predicate.
            \medskip\\
            As for the actions, the only ones necessary are the movement ones, named \textit{right}, \textit{left}, \textit{up}, and \textit{down} (distinct from the predicates with the same names). Each action takes three parameters: the agent, the current tile, and the destination tile. Using \textit{right} as an example, the preconditions are: the agent is \textit{me}, is located at the current tile, the destination tile is to the right of the current tile, and the destination tile is free. If these preconditions are met, the effects are applied: the agent is now at the destination tile and no longer at the initial tile; the initial tile becomes free, and the destination tile becomes occupied.

        \subsubsection{Problem Definition}
            Unlike the domain, the problem must be defined dynamically, as the environment changes continuously. To handle this, the problem definition is embedded directly within the agent's belief using the dedicated planning classes presented in the laboratories.
            \medskip\\
            A new instance of the "\textit{Beliefset}" class (distinct from the custom "\textit{BeliefSet}" class) is created during the agent's "\textit{BeliefSet}" constructor. When the agent receives map information from the server, it builds its internal map representation and then uses this to build the corresponding planning structure. Each walkable tile is represented as "\textit{x<x coord>y<y coord>}", instantiated as a \textit{tile} entity, initially marked as \textit{free}, and connected to its neighbors using directional predicates.
            \medskip\\
            As the environment evolves and the agents senses it, the planning belief must be updated accordingly. After every \textit{onYou} update, the agent's position is updated by invalidating the previous \textit{at} predicate, marking the previous tile as \textit{free}, removing the \textit{free} predicate from the new tile, and declaring the new \textit{at} predicate. This update is also performed after every movement during the \textit{Move} plan to ensure consistent and current state information. Similarly, other agents' positions are updated in the planning belief by adjusting the \textit{free} predicate in both the \textit{onAgentsSensing} handler and the \textit{reviseMemory} function.
            \medskip\\
            At this stage, the planning belief set is fully updated and ready to generate a problem file, following the method presented in the laboratories. A dedicated function was implemented to perform this operation. It takes as input the coordinates of the destination cell for the "\textit{go\_to}" intention and sets the agent being \textit{at} that position as the problem goal.
            \medskip\\
            After generating the problem file, a post-processing step is applied to correct an issue observed during testing. Specifically, the "\textit{Beliefset}" class used in the laboratories, when performing an undeclare, adds negative atoms instead of simply removing the corresponding positive ones. This behavior violates the \textit{closed world assumption} and leads to semantic inconsistencies. Additionally, it causes the FF planner to crash if a negative atom appears in the final position of the problem's initial state. To resolve this, a regular expression is used to remove all negative atoms from the generated problem file.

        \subsubsection{Applying the Automated Planner}
            As previously discussed, automated planning is applied to compute navigation paths within the \textit{Move} plan. Once the problem string is defined, it is passed, along with the domain file, to the \textit{onlineSolver} function presented in the laboratories. This function returns a plan consisting of a sequence of actions from the agent's current position to the desired destination.
            \medskip\\
            The resulting plan is then parsed: each action is converted into the same format used by the BFS-based pathfinding algorithm (e.g., a sequence such as ["UP", "LEFT", "LEFT", "UP"] is converted to ["U", "L", "L", "U"]). After this conversion, the \textit{Move} plan proceeds as usual. If the planner fails to return a valid plan, the intention is immediately failed.
            \medskip\\
            To maintain compatibility with multi-agent mode, which is not specifically designed for automated planning, planning is applied on a probabilistic basis. For the single-agent scenario, the default probability of using automated planning is 50\%, but this can be adjusted when launching the agent's script. In contrast, for the multi-agent scenario, the planning probability is automatically set to 0\% and cannot be modified.

        \subsubsection{Planning Considerations}
            The \textit{Deliveroo.js} environment is highly competitive and rapidly evolving, making automated planning impractical. The primary issue is the time required to compute a plan: even in the smallest tested maps, the number of atoms is large, producing a vast search space. This becomes unmanageable when using a generic planner without the possibility to introduce a suitable heuristic to guide the search. To mitigate this, a dedicated flag was added to block the option generation phase during plan computation.
            \medskip\\
            Another issue concerns the main strategy: rather than adapting the current intention to the changed context, a new intention is generated to replace it. This is problematic because by the time the new plan is ready, the environment has significantly changed. As a result, the option generation process selects a new intention based on the updated state, thus the agent repeatedly generates plans that are never executed. To address this, a dedicated parameter ("\textit{-w}"), which can be set during the agent's script execution, was introduced. If set, this parameter extends the effect of the previous flag to the entire \textit{Move} plan, forcing the agent to complete the "\textit{go\_to}" intention before considering new ones.
            \medskip\\
            Generic automated planning, by its nature, remains unsuitable for this setting. Multiple planners were tested, even on local machines, but plan generation time remains excessive. As a result, most plans are obsolete by the time they are produced due to environmental changes. The current planning infrastructure is retained only as a proof of concept, demonstrating that planning is possible in autonomous agent contexts and, with an adequate structure and domain-specific heuristics, automated planning can be effective in different situations.

\ifthenelse{\value{cols}=1}{
    \end{multicols}
}{
    % Pass
}
